<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scroll Animation (Sticky Sequence + Debug)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    #progressBar { position: fixed; top: 0; left: 0; height: 4px; width: 0; z-index: 50; }
    .reveal { opacity: 0; transform: translateY(40px); transition: opacity .7s ease, transform .7s ease; }
    .reveal.is-visible { opacity: 1; transform: translateY(0); }
    #seqFrame { image-rendering: auto; }
    .debug-chip { position:absolute; top:12px; right:12px; padding:6px 10px; font-size:12px; border-radius:10px; background:rgba(2,6,23,.7); color:#cbd5e1; }
  </style>
</head>
<body class="antialiased bg-slate-950 text-slate-100">
  <div id="progressBar" class="bg-indigo-500"></div>

  <header class="relative min-h-[120vh] overflow-hidden flex items-center justify-center">
    <div class="relative z-10 text-center px-6">
        <h1> hi im emory</h1>
    </div>
  </header>

  <section id="seq" class="relative h-[250vh]">
    <div class="sticky top-0 h-screen grid place-items-center bg-slate-950">
      <div class="text-center px-6 w-full">
        <p class="mt-3 text-slate-300 max-w-xl mx-auto">animation</p>

        <div class="relative mt-8 mx-auto w-[70vmin] h-[70vmin] rounded-2xl overflow-hidden ring-1 ring-white/10 bg-slate-900/60 grid place-items-center">
          <div id="seqFrame" class="w-full h-full bg-center bg-cover will-change-transform"></div>
          <div class="debug-chip" id="debugChip">frame: 0 | url: (waiting)</div>
        </div>

        <p class="mt-4 text-slate-500 text-sm">Expected files: <code>/frames/frame_0001.jpeg</code> â€¦ <code>frame_0060.jpeg</code> (change count/path in JS).</p>
      </div>
    </div>
  </section>

  <script>
    // Progress bar
    const progressBar = document.getElementById('progressBar');
    const updateProgress = () => {
      const st = document.documentElement.scrollTop || document.body.scrollTop;
      const sh = document.documentElement.scrollHeight - document.documentElement.clientHeight;
      progressBar.style.width = (sh > 0 ? (st / sh) * 100 : 0) + '%';
    };
    document.addEventListener('scroll', updateProgress, { passive: true });
    updateProgress();

    const els = document.querySelectorAll('.reveal');
    const io = new IntersectionObserver((entries) => {
      entries.forEach((e) => { if (e.isIntersecting) e.target.classList.add('is-visible'); });
    }, { threshold: 0.2 });
    els.forEach((el) => io.observe(el));

const SEQ = {
  frameCount: 3, // update to match actual number of frames
  pad: 4,
  path: (i) => `./frames/frame_${String(i).padStart(4, '0')}.jpeg`, 
};

const seqEl   = document.getElementById('seq');
const frameEl = document.getElementById('seqFrame');
const debugEl = document.getElementById('debugChip');
let ticking = false;
let progress = 0;
let seqActive = false;

(function initFirstFrame() {
  const url = SEQ.path(1);
  frameEl.style.backgroundImage = `url('${url}')`;
  frameEl.style.backgroundSize = 'cover';
  frameEl.style.backgroundPosition = 'center';
  frameEl.dataset.cur = '1';
  if (debugEl) debugEl.textContent = `frame: 1 | url: ${url}`;
})();

// Observe when sticky section enters/leaves viewport
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    seqActive = entry.isIntersecting;
    if (seqActive) {
      renderFrame(0);
      onScroll();
    } else {
      if (debugEl) debugEl.textContent = `frame: 1 | url: ${SEQ.path(1)}`;
      frameEl.style.backgroundImage = `url('${SEQ.path(1)}')`;
      frameEl.dataset.cur = '1';
    }
  });
}, { threshold: 0 });
observer.observe(seqEl);

function computeStickyProgress(section) {
  const rect = section.getBoundingClientRect();
  const vh = window.innerHeight || document.documentElement.clientHeight;
  const total = rect.height - vh;
  const passed = Math.min(Math.max(vh - Math.max(0, rect.top), 0), total);
  const p = total > 0 ? passed / total : 0;
  return Math.min(Math.max(p, 0), 1);
}

function renderFrame(p) {
  const idx = Math.max(1, 1 + Math.round(p * (SEQ.frameCount - 1)));
  const url = SEQ.path(idx);
  frameEl.style.backgroundImage = `url('${url}')`;
  frameEl.dataset.cur = String(idx);
  if (debugEl) debugEl.textContent = `frame: ${idx} | url: ${url}`;
}

function onScroll() {
  if (!seqActive) return;
  progress = computeStickyProgress(seqEl);
  if (!ticking) {
    requestAnimationFrame(() => {
      renderFrame(progress);
      ticking = false;
    });
    ticking = true;
  }
}

document.addEventListener('scroll', onScroll, { passive: true });
window.addEventListener('resize', onScroll);
</script>
</body>
</html>